in vec3 ray_direction;
in vec3 camera_trans;
flat in vec3 position_trans;

uniform vec3 scale;
uniform highp sampler3D volume;
uniform float iso;

void main(){
    vec3 direction = normalize(ray_direction);

    // intersect with bounding box
    const vec3 box_min = vec3(0);
    const vec3 box_max = vec3(1);
    vec3 current_paramMin = (box_min - camera_trans) / direction;
    vec3 current_paramMax = (box_max - camera_trans) / direction;
    vec3 paramMin = min(current_paramMin, current_paramMax);
    vec3 paramMax = max(current_paramMin, current_paramMax);
    float param0 = max(paramMin.x, max(paramMin.y, paramMin.z));
    float param1 = min(paramMax.x, min(paramMax.y, paramMax.z));
    vec2 hit = vec2(param0, param1);

    if (hit.x > hit.y) {
        discard;
    }
    hit.x = max(0.0, hit.x);
    // start position
    vec3 current_position = camera_trans + hit.x * direction;
    vec3 previous_position = current_position;
    // compute the step size
    vec3 stepSize_dir = 1.0 / vec3(scale);
    float stepSize = min(stepSize_dir.x, min(stepSize_dir.y, stepSize_dir.z));

    float current_voxel;
    float opacity = 0.0;
    vec3 color = vec3(0);

    float previous_voxel = texture(volume, current_position.xyz).r;

    for (float param = hit.x; param < hit.y; param += stepSize) {
        current_position += direction * stepSize;
        current_voxel = texture(volume, current_position.xyz).r;

        //if (current_voxel > opacity) {
        //    opacity = current_voxel;
        //    color = vec3(1.0);
        //}

        //checking if iso value between previous density value and next one
        float lowerBound = min(previous_voxel, current_voxel);
        float upperBound = max(previous_voxel, current_voxel);

        if(iso < upperBound && iso > lowerBound){
        //interpolate
        float linInterPol = (iso - previous_voxel)/(current_voxel - previous_voxel);
        vec3 final_position = mix(previous_position, current_position, linInterPol);

        //gradient
        float epsilon = 0.004;
        vec3 epsilonX = vec3(epsilon,0.0,0.0);
        vec3 epsilonY = vec3(0.0,epsilon,0.0);
        vec3 epsilonZ = vec3(0.0,0.0,epsilon);
        vec3 normal;
        normal.x = texture(volume, final_position - epsilonX).r - texture(volume, final_position + epsilonX).r;
        normal.y = texture(volume, final_position - epsilonY).r - texture(volume, final_position + epsilonY).r;
        normal.z = texture(volume, final_position - epsilonZ).r - texture(volume, final_position + epsilonZ).r;


        //calculate Phong Shading
        vec3 color = vec3(length(normal), 1.0, 1.0);
        normal = normalize(normal);
        float k_ambient = 0.3;
        float k_diff = 0.7;
        float diffuse = k_diff*max(dot(direction, normal), 0.0);
        vec3 refDir = reflect(-direction, normal);
        float k_spec = 0.2;
        float specular = k_spec*pow(max(dot(direction, refDir), 0.0), 3.0);
        color = (k_ambient + diffuse) * color + specular;
        }
        previous_voxel = current_voxel;
        previous_position = current_position;
    }


    gl_FragColor = vec4(color, opacity);
}